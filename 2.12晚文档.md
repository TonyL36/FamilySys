对话总结反思收获（大学生口吻）

一、项目背景与我的目标
这次主要是修复家谱系统里“远亲关系称谓反了”的问题。规则很明确：数据库里的语义是“member1 是 member2 的关系”，所以展示时必须严格按这个方向来，否则就会出现爷爷变孙女、外祖父变外孙这种尴尬问题。我的目标是：
1. 修正关系方向，让远亲图展示方向和存储语义一致。
2. 修复祖孙/外祖父母的存储方向，保证查询时不再乱。
3. 做一套可复现的测试流程，确保问题真的解决了。
4. 家族真实数据不允许同步到远端，只留代码和文档。

二、我改了哪些地方（带代码片段）
1. 修正远亲路径的边方向展示逻辑
我在 FamilyRelationshipCalculator 里确认了边的方向含义：from→to 的展示必须是“to 是 from 的称谓”。核心改动如下：

```java
private String edgeDescriptionForDirection(Relationship rel, int fromId, int toId, Map<Integer, Member> memberMap) {
    if (rel.getMember1() == fromId && rel.getMember2() == toId)
        return rel.getRelationshipDescription();
    if (rel.getMember1() == toId && rel.getMember2() == fromId)
        return getReverseRelationshipDescription(rel.getRelation(), fromId, toId, memberMap);
    
    return getCorrectRelationshipDescription(rel.getRelation(), fromId, toId, null);
}
```

这段逻辑的关键是：如果关系方向和路径方向一致，就直接用关系描述；如果方向相反，就必须反向翻译称谓。

2. 保证 BFS 路径边使用“member1 视角”称谓
为了避免路径拼接时出现“方向错配”，我在构建边时统一使用 getEdgeDescriptionForMember1：

```java
for (int i = 0; i < idOrder.size() - 1; i++) {
    int a = idOrder.get(i), b = idOrder.get(i + 1);
    Relationship r = prevRel.get(b);
    if (r != null) {
        String edgeDesc = getEdgeDescriptionForMember1(r, a, b, memberMap);
        edges.add(new PathEdge(a, b, edgeDesc));
    } else {
        edges.add(new PathEdge(a, b, ""));
    }
}
```

3. 修复祖孙/外祖父母存储方向
核心修复是在 RelationshipService 的 addGrandparentRelationships 里。以前的方向逻辑容易反，导致孙子被记成爷爷。我改成：member1 始终是“当前新增子女”，member2 是“祖辈”，同时用正确的关系码。

```java
if (isPaternal) {
    relationshipRepository.addRelationship(child.getMemberID(), grandparent.getMemberID(),
            grandparent.getGender() == 0 ? 19 : 20);
    relationshipRepository.addRelationship(grandparent.getMemberID(), child.getMemberID(),
            child.getGender() == 0 ? 23 : 24);
} else {
    relationshipRepository.addRelationship(child.getMemberID(), grandparent.getMemberID(),
            grandparent.getGender() == 0 ? 22 : 21);
    relationshipRepository.addRelationship(grandparent.getMemberID(), child.getMemberID(),
            child.getGender() == 0 ? 25 : 26);
}
```

这样就能保证：祖辈对孙辈是“爷爷/奶奶/外祖父/外祖母”，孙辈对祖辈才是“孙子/孙女/外孙/外孙女”。

三、数据测试方法（我怎么验证的）
我为了避免污染真实库，单独做了一个可复现流程：
1. 空库重建：只保留 Members 和 Relationships 表结构。
2. 成员录入顺序：按代际从高到低插入成员。
3. 关系录入顺序：父母 → 配偶 → 子女（长/次/小）。
4. 数据来源：只取“最小基础关系”，让系统自动生成更复杂关系。

关键用例校验：
1. member1=17，member2=51 必须存为“孙子”。
2. 路径展示方向必须跟存储语义一致。

四、测试结果
1. 构建与测试通过。
2. 关键用例通过：member1=17、member2=51 显示为“孙子”。
3. 远亲图展示方向一致，祖孙/外祖关系不再反转。

五、后续优化方向（我觉得可以继续做的）
1. 自动化校验
   - 给祖孙与外祖关系做“正反向称谓对照”的单测。
2. 数据录入工具化
   - 固化“代际顺序 + 关系顺序”流程，减少手工出错。
3. 数据安全
   - family.db 不进 Git，只保留结构和脚本。
4. 前后端一致性
   - 前端关系图验收必须对照后端存储语义。

六、中国家谱问题的经验
1. 称谓特别依赖方向和性别，一旦混用就是灾难级错误。
2. 先保证最基础关系正确，复杂关系才能稳定推导。
3. 父系/母系差别在外祖关系上很明显，必须单独处理。
4. 写清楚“存储语义 vs 展示语义”的边界，比单纯修 bug 更重要。

七、数据同步注意事项（必须遵守）
1. 家族真实数据不能同步到远端。
2. 版本库只保留代码和文档，数据走本地备份或导出文件。

八、安全部署配置（新增）
1. 敏感信息隔离
   - 所有的 API 地址和 Key 已经从 HTML 文件中剥离，统一管理在 amily-frontend-remote/config.js。
   - 该文件被 .gitignore 排除，不会提交到版本库，防止泄露。

2. 部署流程
   - 仓库中提供 config.example.js 作为模板。
   - 部署时，复制 config.example.js 为 config.js。
   - 在 config.js 中填入真实的服务器 IP 和 API Key。

3. 验证方法
   - 提交代码前，运行 git status 确保 config.js 没有出现在待提交列表中。
   - 检查 config.example.js 是否已更新为最新模板（不含真实 Key）。
